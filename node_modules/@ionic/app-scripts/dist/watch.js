"use strict";
var build_1 = require('./build');
var logger_1 = require('./util/logger');
var config_1 = require('./util/config');
var path_1 = require('path');
var chalk = require('chalk');
var chokidar = require('chokidar');
// https://github.com/paulmillr/chokidar
function watch(context, configFile) {
    context = config_1.generateContext(context);
    configFile = config_1.getUserConfigFile(context, taskInfo, configFile);
    // force watch options
    context.isProd = false;
    context.isWatch = true;
    var logger = new logger_1.Logger('watch');
    function buildDone() {
        return startWatchers(context, configFile).then(function () {
            logger.ready(chalk.green);
        });
    }
    return build_1.build(context)
        .then(buildDone, buildDone)
        .catch(function (err) {
        throw logger.fail(err);
    });
}
exports.watch = watch;
function startWatchers(context, configFile) {
    var watchConfig = config_1.fillConfigDefaults(configFile, taskInfo.defaultConfigFile);
    var promises = watchConfig
        .watchers
        .map(function (w, i) { return startWatcher(i, w, context, watchConfig); });
    return Promise.all(promises);
}
function startWatcher(index, watcher, context, watchConfig) {
    return new Promise(function (resolve, reject) {
        prepareWatcher(context, watcher);
        if (!watcher.paths) {
            logger_1.Logger.error("watcher config, index " + index + ": missing \"paths\"");
            resolve();
            return;
        }
        if (!watcher.callback) {
            logger_1.Logger.error("watcher config, index " + index + ": missing \"callback\"");
            resolve();
            return;
        }
        var taskPromise = Promise.resolve();
        var nextTask = null;
        var chokidarWatcher = chokidar.watch(watcher.paths, watcher.options);
        chokidarWatcher.on('all', function (event, filePath) {
            config_1.setIonicEnvironment(context.isProd);
            logger_1.Logger.debug("watch callback start, id: " + watchCount + ", isProd: " + context.isProd + ", event: " + event + ", path: " + filePath);
            function taskDone() {
                logger_1.Logger.info(chalk.green('watch ready'));
            }
            nextTask = watcher.callback.bind(null, event, filePath, context);
            taskPromise.then(function () {
                logger_1.Logger.debug("watch callback complete, id: " + watchCount + ", isProd: " + context.isProd + ", event: " + event + ", path: " + filePath);
                taskPromise = nextTask();
                taskPromise
                    .then(taskDone, taskDone)
                    .catch(taskDone);
                nextTask = null;
                watchCount++;
            }).catch(function (err) {
                logger_1.Logger.debug("watch callback error, id: " + watchCount + ", isProd: " + context.isProd + ", event: " + event + ", path: " + filePath);
                logger_1.Logger.debug("" + err);
                taskPromise = nextTask();
                taskPromise
                    .then(taskDone, taskDone)
                    .catch(taskDone);
                nextTask = null;
                watchCount++;
            });
        });
        chokidarWatcher.on('ready', function () {
            logger_1.Logger.debug("watcher ready: " + watcher.options.cwd + watcher.paths);
            resolve();
        });
        chokidarWatcher.on('error', function (err) {
            reject(new logger_1.BuildError("watcher error: " + watcher.options.cwd + watcher.paths + ": " + err));
        });
    });
}
function prepareWatcher(context, watcher) {
    watcher.options = watcher.options || {};
    if (!watcher.options.cwd) {
        watcher.options.cwd = context.rootDir;
    }
    if (typeof watcher.options.ignoreInitial !== 'boolean') {
        watcher.options.ignoreInitial = true;
    }
    if (typeof watcher.options.ignored === 'string') {
        watcher.options.ignored = path_1.normalize(config_1.replacePathVars(context, watcher.options.ignored));
    }
    if (typeof watcher.paths === 'string') {
        watcher.paths = path_1.normalize(config_1.replacePathVars(context, watcher.paths));
    }
    else if (Array.isArray(watcher.paths)) {
        watcher.paths = watcher.paths.map(function (p) { return path_1.normalize(config_1.replacePathVars(context, p)); });
    }
}
exports.prepareWatcher = prepareWatcher;
var taskInfo = {
    fullArgConfig: '--watch',
    shortArgConfig: '-w',
    envConfig: 'ionic_watch',
    defaultConfigFile: 'watch.config'
};
var watchCount = 0;
