"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var path_1 = require('path');
var config_1 = require('./config');
var fs_extra_1 = require('fs-extra');
var chalk = require('chalk');
var BuildError = (function (_super) {
    __extends(BuildError, _super);
    function BuildError(err) {
        _super.call(this);
        this.hasBeenLogged = false;
        if (err) {
            if (err.message) {
                this.message = err.message;
            }
            else if (err) {
                this.message = err;
            }
            if (err.stack) {
                this.stack = err.stack;
            }
            if (err.name) {
                this.name = err.name;
            }
            if (typeof err.hasBeenLogged === 'boolean') {
                this.hasBeenLogged = err.hasBeenLogged;
            }
        }
    }
    BuildError.prototype.toJson = function () {
        return {
            message: this.message,
            name: this.name,
            stack: this.stack,
            hasBeenLogged: this.hasBeenLogged
        };
    };
    return BuildError;
}(Error));
exports.BuildError = BuildError;
var Logger = (function () {
    function Logger(scope) {
        this.start = Date.now();
        this.scope = scope;
        var msg = scope + " started " + chalk.dim('...');
        if (config_1.isDebugMode()) {
            msg += memoryUsage();
        }
        Logger.info(msg);
    }
    Logger.prototype.ready = function (chalkColor) {
        this.completed('ready', chalkColor);
    };
    Logger.prototype.finish = function (chalkColor) {
        this.completed('finished', chalkColor);
    };
    Logger.prototype.completed = function (msg, chalkColor) {
        var duration = Date.now() - this.start;
        var time;
        if (duration > 1000) {
            time = 'in ' + (duration / 1000).toFixed(2) + ' s';
        }
        else {
            var ms = parseFloat((duration).toFixed(3));
            if (ms > 0) {
                time = 'in ' + duration + ' ms';
            }
            else {
                time = 'in less than 1 ms';
            }
        }
        msg = this.scope + " " + msg;
        if (chalkColor) {
            msg = chalkColor(msg);
        }
        msg += ' ' + chalk.dim(time);
        if (config_1.isDebugMode()) {
            msg += memoryUsage();
        }
        Logger.info(msg);
    };
    Logger.prototype.fail = function (err) {
        if (err) {
            if (err instanceof BuildError) {
                var failedMsg = this.scope + " failed";
                if (err.message) {
                    failedMsg += ": " + err.message;
                }
                if (!err.hasBeenLogged) {
                    Logger.error("" + failedMsg);
                    err.hasBeenLogged = true;
                    if (err.stack && config_1.isDebugMode()) {
                        Logger.debug(err.stack);
                    }
                }
                else if (config_1.isDebugMode()) {
                    Logger.debug("" + failedMsg);
                }
                return err;
            }
        }
        return err;
    };
    /**
     * Does not print out a time prefix or color any text. Only prefix
     * with whitespace so the message is lined up with timestamped logs.
     */
    Logger.log = function () {
        var msg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            msg[_i - 0] = arguments[_i];
        }
        Logger.wordWrap(msg).forEach(function (line) {
            console.log(line);
        });
    };
    /**
     * Prints out a dim colored timestamp prefix.
     */
    Logger.info = function () {
        var msg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            msg[_i - 0] = arguments[_i];
        }
        var lines = Logger.wordWrap(msg);
        if (lines.length) {
            var prefix = timePrefix();
            lines[0] = chalk.dim(prefix) + lines[0].substr(prefix.length);
        }
        lines.forEach(function (line) {
            console.log(line);
        });
    };
    /**
     * Prints out a yellow colored timestamp prefix.
     */
    Logger.warn = function () {
        var msg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            msg[_i - 0] = arguments[_i];
        }
        var lines = Logger.wordWrap(msg);
        if (lines.length) {
            var prefix = timePrefix();
            lines[0] = prefix + lines[0].substr(prefix.length);
        }
        lines.forEach(function (line) {
            console.warn(chalk.yellow(line));
        });
    };
    /**
     * Prints out a error colored timestamp prefix.
     */
    Logger.error = function () {
        var msg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            msg[_i - 0] = arguments[_i];
        }
        var lines = Logger.wordWrap(msg);
        if (lines.length) {
            var prefix = timePrefix();
            lines[0] = prefix + lines[0].substr(prefix.length);
            if (config_1.isDebugMode()) {
                lines[0] += memoryUsage();
            }
        }
        lines.forEach(function (line) {
            console.error(chalk.red(line));
        });
    };
    /**
     * Prints out a blue colored DEBUG prefix. Only prints out when debug mode.
     */
    Logger.debug = function () {
        var msg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            msg[_i - 0] = arguments[_i];
        }
        if (config_1.isDebugMode()) {
            msg.push(memoryUsage());
            var lines = Logger.wordWrap(msg);
            if (lines.length) {
                var prefix = '[ DEBUG! ]';
                lines[0] = prefix + lines[0].substr(prefix.length);
            }
            lines.forEach(function (line) {
                console.log(chalk.cyan(line));
            });
        }
    };
    Logger.printErrorLines = function (errorLines) {
        removeWhitespaceIndent(errorLines);
        errorLines.forEach(function (l) {
            var msg = 'L' + l.lineNumber + ':  ';
            while (msg.length < Logger.INDENT.length) {
                msg = ' ' + msg;
            }
            msg = chalk.dim(msg) + Logger.jsSyntaxHighlight(l.text);
            console.log(msg);
        });
        Logger.newLine();
    };
    Logger.highlightError = function (errorLine, errorCharStart, errorCharLength) {
        var rightSideChars = errorLine.length - errorCharStart + errorCharLength - 1;
        while (errorLine.length + Logger.INDENT.length > Logger.MAX_LEN) {
            if (errorCharStart > (errorLine.length - errorCharStart + errorCharLength) && errorCharStart > 5) {
                // larger on left side
                errorLine = errorLine.substr(1);
                errorCharStart--;
            }
            else if (rightSideChars > 1) {
                // larger on right side
                errorLine = errorLine.substr(0, errorLine.length - 1);
                rightSideChars--;
            }
            else {
                break;
            }
        }
        var lineChars = errorLine.split('');
        for (var i = 0; i < lineChars.length; i++) {
            if (i >= errorCharStart && i < errorCharStart + errorCharLength) {
                lineChars[i] = chalk.bgRed(lineChars[i]);
            }
        }
        return lineChars.join('');
    };
    Logger.wordWrap = function (msg) {
        var output = [];
        var words = [];
        msg.forEach(function (m) {
            if (m === null) {
                words.push('null');
            }
            else if (typeof m === 'undefined') {
                words.push('undefined');
            }
            else if (typeof m === 'string') {
                m.replace(/\s/gm, ' ').split(' ').forEach(function (strWord) {
                    if (strWord.trim().length) {
                        words.push(strWord.trim());
                    }
                });
            }
            else if (typeof m === 'number' || typeof m === 'boolean') {
                words.push(m.toString());
            }
            else if (typeof m === 'function') {
                words.push(m.toString());
            }
            else if (Array.isArray(m)) {
                words.push(function () {
                    return m.toString();
                });
            }
            else if (Object(m) === m) {
                words.push(function () {
                    return m.toString();
                });
            }
            else {
                words.push(m.toString());
            }
        });
        var line = Logger.INDENT;
        words.forEach(function (word) {
            if (typeof word === 'function') {
                if (line.trim().length) {
                    output.push(line);
                }
                output.push(word());
                line = Logger.INDENT;
            }
            else if (Logger.INDENT.length + word.length > Logger.MAX_LEN) {
                // word is too long to play nice, just give it its own line
                if (line.trim().length) {
                    output.push(line);
                }
                output.push(Logger.INDENT + word);
                line = Logger.INDENT;
            }
            else if ((word.length + line.length) > Logger.MAX_LEN) {
                // this word would make the line too long
                // print the line now, then start a new one
                output.push(line);
                line = Logger.INDENT + word + ' ';
            }
            else {
                line += word + ' ';
            }
        });
        if (line.trim().length) {
            output.push(line);
        }
        return output;
    };
    Logger.meaningfulLine = function (line) {
        if (line) {
            line = line.trim();
            if (line.length) {
                return (MEH_LINES.indexOf(line) < 0);
            }
        }
        return false;
    };
    Logger.jsSyntaxHighlight = function (text) {
        if (text.trim().startsWith('//')) {
            return chalk.dim(text);
        }
        var words = text.split(' ').map(function (word) {
            if (JS_KEYWORDS.indexOf(word) > -1) {
                return chalk.cyan(word);
            }
            return word;
        });
        return words.join(' ');
    };
    Logger.formatHeader = function (task, filename, rootDir, startLineNumber, endLineNumber) {
        if (startLineNumber === void 0) { startLineNumber = null; }
        if (endLineNumber === void 0) { endLineNumber = null; }
        var header = task + ": ";
        filename = filename.replace(rootDir, '');
        if (/\/|\\/.test(filename.charAt(0))) {
            filename = filename.substr(1);
        }
        if (filename.length > 80) {
            filename = '...' + filename.substr(filename.length - 80);
        }
        if (startLineNumber !== null && startLineNumber > 0) {
            header += filename + ', ';
            if (endLineNumber !== null && endLineNumber > startLineNumber) {
                header += "lines: " + startLineNumber + " - " + endLineNumber;
            }
            else {
                header += "line: " + startLineNumber;
            }
        }
        return header;
    };
    Logger.newLine = function () {
        console.log('');
    };
    Logger.INDENT = '            ';
    Logger.MAX_LEN = 120;
    return Logger;
}());
exports.Logger = Logger;
function removeWhitespaceIndent(lines) {
    for (var i = 0; i < 100; i++) {
        if (!eachLineHasLeadingWhitespace(lines)) {
            return;
        }
        for (var i = 0; i < lines.length; i++) {
            lines[i].text = lines[i].text.substr(1);
            if (!lines[i].text.length) {
                return;
            }
        }
    }
}
function eachLineHasLeadingWhitespace(lines) {
    if (!lines.length) {
        return false;
    }
    for (var i = 0; i < lines.length; i++) {
        if (lines[i].text.length < 1) {
            return false;
        }
        var firstChar = lines[i].text.charAt(0);
        if (firstChar !== ' ' && firstChar !== '\t') {
            return false;
        }
    }
    return true;
}
function timePrefix() {
    var date = new Date();
    return '[' + ('0' + date.getHours()).slice(-2) + ':' + ('0' + date.getMinutes()).slice(-2) + ':' + ('0' + date.getSeconds()).slice(-2) + ']';
}
function memoryUsage() {
    return chalk.dim(" MEM: " + (process.memoryUsage().rss / 1000000).toFixed(1) + "MB");
}
function getAppScriptsVersion() {
    var rtn = '';
    try {
        var packageJson = fs_extra_1.readJSONSync(path_1.join(__dirname, '..', '..', 'package.json'));
        rtn = packageJson.version || '';
    }
    catch (e) { }
    return rtn;
}
exports.getAppScriptsVersion = getAppScriptsVersion;
var JS_KEYWORDS = [
    'as',
    'break',
    'case',
    'catch',
    'class',
    'const',
    'continue',
    'debugger',
    'default',
    'delete',
    'do',
    'else',
    'export',
    'extends',
    'finally',
    'for',
    'from',
    'function',
    'if',
    'import',
    'in',
    'instanceof',
    'new',
    'return',
    'super',
    'switch',
    'this',
    'throw',
    'try',
    'typeof',
    'var',
    'void',
    'while',
];
var MEH_LINES = [';', ':', '{', '}', '(', ')', '/**', '/*', '*/', '*', '({', '})'];
