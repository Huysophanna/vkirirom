"use strict";
var logger_1 = require('./util/logger');
var bundle_1 = require('./bundle');
var helpers_1 = require('./util/helpers');
var config_1 = require('./util/config');
var template_1 = require('./template');
var path_1 = require('path');
var lint_1 = require('./lint');
var fs_1 = require('fs');
var logger_typescript_1 = require('./util/logger-typescript');
var worker_client_1 = require('./worker-client');
var ts = require('typescript');
function transpile(context) {
    context = config_1.generateContext(context);
    var workerConfig = {
        configFile: getTsConfigPath(context),
        writeInMemory: true,
        sourceMaps: true,
        cache: true,
        inlineTemplate: context.inlineTemplates
    };
    var logger = new logger_1.Logger('transpile');
    return transpileWorker(context, workerConfig)
        .then(function () {
        logger.finish();
    })
        .catch(function (err) {
        throw logger.fail(err);
    });
}
exports.transpile = transpile;
function transpileUpdate(event, filePath, context) {
    if (!filePath.endsWith('.ts') && cachedTsFiles) {
        // however this ran, the changed file wasn't a .ts file
        // so if we already have tsFiles then make sure the context
        // has them and carry on
        context.tsFiles = cachedTsFiles;
        return Promise.resolve();
    }
    var workerConfig = {
        configFile: getTsConfigPath(context),
        writeInMemory: true,
        sourceMaps: true,
        cache: false,
        inlineTemplate: context.inlineTemplates
    };
    var logger = new logger_1.Logger('transpile update');
    return transpileUpdateWorker(event, filePath, context, workerConfig)
        .then(function (tsFiles) {
        logger.finish();
    })
        .catch(function (err) {
        throw logger.fail(err);
    });
}
exports.transpileUpdate = transpileUpdate;
/**
 * The full TS build for all app files.
 */
function transpileWorker(context, workerConfig) {
    // forget any tsFiles we've already cached
    if (workerConfig.writeInMemory) {
        context.tsFiles = null;
    }
    // let's do this
    return new Promise(function (resolve, reject) {
        // get the tsconfig data
        var tsConfig = getTsConfig(context, workerConfig.configFile);
        if (workerConfig.sourceMaps === false) {
            // the worker config say, "hey, don't ever bother making a source map, because."
            tsConfig.options.sourceMap = false;
        }
        else {
            // build the ts source maps if the bundler is going to use source maps
            tsConfig.options.sourceMap = bundle_1.buildJsSourceMaps(context);
        }
        // collect up all the files we need to transpile, tsConfig itself does all this for us
        var tsFileNames = cleanFileNames(context, tsConfig.fileNames);
        // for dev builds let's not create d.ts files
        tsConfig.options.declaration = undefined;
        // let's start a new tsFiles object to cache all the transpiled files in
        var tsFiles = {};
        var host = ts.createCompilerHost(tsConfig.options);
        var program = ts.createProgram(tsFileNames, tsConfig.options, host, cachedProgram);
        program.emit(undefined, function (path, data) {
            if (workerConfig.writeInMemory) {
                writeCallback(tsFiles, path, data, workerConfig.inlineTemplate);
            }
        });
        var hasDiagnostics = logger_typescript_1.runDiagnostics(context, program);
        if (hasDiagnostics) {
            // transpile failed :(
            cachedProgram = cachedTsFiles = null;
            reject(new logger_1.BuildError());
        }
        else {
            // transpile success :)
            // cache the typescript program for later use
            cachedProgram = program;
            if (workerConfig.writeInMemory) {
                context.tsFiles = tsFiles;
            }
            if (workerConfig.cache) {
                cachedTsFiles = tsFiles;
            }
            resolve();
        }
    });
}
exports.transpileWorker = transpileWorker;
/**
 * Iterative build for one TS file. If it's not an existing file change, or
 * something errors out then it falls back to do the full build.
 */
function transpileUpdateWorker(event, filePath, context, workerConfig) {
    filePath = path_1.resolve(filePath);
    // let's run tslint on this one file too, but run it in another
    // processor core and don't let it's results hang anything up
    lint_1.lintUpdate(event, filePath, context);
    if (event === 'change' && context.tsFiles && context.tsFiles[filePath]) {
        try {
            // an existing ts file we already know about has changed
            // let's "TRY" to do a single module build for this one file
            var tsConfig = getTsConfig(context, workerConfig.configFile);
            // build the ts source maps if the bundler is going to use source maps
            tsConfig.options.sourceMap = bundle_1.buildJsSourceMaps(context);
            var transpileOptions = {
                compilerOptions: tsConfig.options,
                fileName: filePath,
                reportDiagnostics: true
            };
            // let's manually transpile just this one ts file
            // load up the source text for this one module
            var sourceText = fs_1.readFileSync(filePath, 'utf8');
            // transpile this one module
            var transpileOutput = ts.transpileModule(sourceText, transpileOptions);
            if (transpileOutput.diagnostics.length) {
                // darn, we've got some errors with this transpiling :(
                // but at least we reported the errors like really really fast, so there's that
                logger_1.Logger.debug("transpileUpdateWorker: transpileModule, diagnostics: " + transpileOutput.diagnostics.length);
                transpileOutput.diagnostics.forEach(function (d) {
                    logger_typescript_1.printDiagnostic(context, d);
                });
                return Promise.reject(new logger_1.BuildError());
            }
            else if (!transpileOutput.outputText) {
                // derp, not sure how there's no output text, just do a full build
                logger_1.Logger.debug("transpileUpdateWorker: transpileModule, missing output text");
            }
            else {
                var tsFile = context.tsFiles[filePath];
                if (tsFile) {
                    // success!! no need for a full rebuild!!!
                    tsFile.input = sourceText;
                    tsFile.map = transpileOutput.sourceMapText;
                    if (workerConfig.inlineTemplate) {
                        tsFile.output = template_1.inlineTemplate(transpileOutput.outputText, filePath);
                    }
                    // cool, the lil transpiling went through, but
                    // let's still do the big transpiling (on another processor core)
                    // and if there's anything wrong it'll print out messages
                    // however, it doesn't hang anything up
                    // also make sure it does a little as possible
                    var fullBuildWorkerConfig = {
                        configFile: workerConfig.configFile,
                        writeInMemory: false,
                        sourceMaps: false,
                        cache: false,
                        inlineTemplate: false
                    };
                    worker_client_1.runWorker('transpile', 'transpileWorker', context, fullBuildWorkerConfig);
                    return Promise.resolve();
                }
            }
        }
        catch (e) {
            // umm, oops. Yeah let's just do a full build then
            logger_1.Logger.debug("transpileModule error: " + e);
        }
    }
    // do a full build if it wasn't an existing file that changed
    // or we haven't transpiled the whole thing yet
    // or there were errors trying to transpile just the one module
    logger_1.Logger.debug("transpileUpdateWorker: full build, context.tsFiles " + !!context.tsFiles + ", event: " + event + ", file: " + filePath);
    return transpileWorker(context, workerConfig);
}
function cleanFileNames(context, fileNames) {
    // make sure we're not transpiling the prod when dev and stuff
    var removeFileName = (context.isProd) ? 'main.dev.ts' : 'main.prod.ts';
    return fileNames.filter(function (f) { return (f.indexOf(removeFileName) === -1); });
}
function writeCallback(tsFiles, sourcePath, data, shouldInlineTemplate) {
    sourcePath = path_1.normalize(sourcePath);
    if (helpers_1.endsWith(sourcePath, '.js')) {
        sourcePath = sourcePath.substring(0, sourcePath.length - 3) + '.ts';
        var file = tsFiles[sourcePath];
        if (!file) {
            file = tsFiles[sourcePath] = {};
        }
        if (shouldInlineTemplate) {
            file.output = template_1.inlineTemplate(data, sourcePath);
        }
        else {
            file.output = data;
        }
    }
    else if (helpers_1.endsWith(sourcePath, '.js.map')) {
        sourcePath = sourcePath.substring(0, sourcePath.length - 7) + '.ts';
        var file = tsFiles[sourcePath];
        if (!file) {
            file = tsFiles[sourcePath] = {};
        }
        file.map = data;
    }
}
function getTsConfig(context, tsConfigPath) {
    var config = null;
    tsConfigPath = tsConfigPath || getTsConfigPath(context);
    var tsConfigFile = ts.readConfigFile(tsConfigPath, function (path) { return fs_1.readFileSync(path, 'utf8'); });
    if (!tsConfigFile) {
        throw new logger_1.BuildError("tsconfig: invalid tsconfig file, \"" + tsConfigPath + "\"");
    }
    else if (tsConfigFile.error && tsConfigFile.error.messageText) {
        throw new logger_1.BuildError("tsconfig: " + tsConfigFile.error.messageText);
    }
    else if (!tsConfigFile.config) {
        throw new logger_1.BuildError("tsconfig: invalid config, \"" + tsConfigPath + "\"\"");
    }
    else {
        var parsedConfig = ts.parseJsonConfigFileContent(tsConfigFile.config, ts.sys, context.rootDir, {}, tsConfigPath);
        if (parsedConfig.errors && parsedConfig.errors.length) {
            parsedConfig.errors.forEach(function (d) {
                logger_typescript_1.printDiagnostic(context, d);
            });
            throw new logger_1.BuildError();
        }
        config = {
            options: parsedConfig.options,
            fileNames: parsedConfig.fileNames,
            typingOptions: parsedConfig.typingOptions,
            raw: parsedConfig.raw
        };
    }
    return config;
}
exports.getTsConfig = getTsConfig;
var cachedProgram = null;
var cachedTsFiles = null;
function getTsConfigPath(context) {
    return path_1.join(context.rootDir, 'tsconfig.json');
}
exports.getTsConfigPath = getTsConfigPath;
